"#[doc =\n\" Contract module which acts as a time-locked controller. When set as the\"]\n#[doc =\n\" owner of an `Ownable` smart contract, it enforces a timelock on all\"]\n#[doc =\n\" `onlyOwner` maintenance operations. This gives time for users of the\"]\n#[doc =\n\" controlled contract to exit before a potentially dangerous maintenance\"]\n#[doc = \" operation is applied.\"] #[doc = \"\"]\n#[doc =\n\" By default, this contract is self-administered, meaning administration tasks\"]\n#[doc =\n\" have to go through the timelock process. The proposer (resp executor) role\"]\n#[doc =\n\" is in charge of proposing (resp executing) operations. A common use case is\"]\n#[doc =\n\" to position this `TimelockController` as the owner of a smart contract, with\"]\n#[doc = \" a multisig or a DAO as the sole proposer.\"] pub trait\nTimelockController : AccessControl\n{\n    #[doc =\n    \" Returns whether an id correspond to a registered operation. This\"]\n    #[doc = \" includes both Pending, Ready and Done operations.\"]\n    #[ink(message)] #[ink(selector = 833179961u32)] fn\n    is_operation(& self, id : OperationId) -> bool ;\n    #[doc = \" Returns whether an operation is pending or not.\"]\n    #[ink(message)] #[ink(selector = 2852774521u32)] fn\n    is_operation_pending(& self, id : OperationId) -> bool ;\n    #[doc = \" Returns whether an operation is ready or not.\"] #[ink(message)]\n    #[ink(selector = 3325091074u32)] fn\n    is_operation_ready(& self, id : OperationId) -> bool ;\n    #[doc = \" Returns whether an operation is done or not.\"] #[ink(message)]\n    #[ink(selector = 1049548971u32)] fn\n    is_operation_done(& self, id : OperationId) -> bool ;\n    #[doc =\n    \" Returns the timestamp at with an operation becomes ready (0 for\"]\n    #[doc = \" unset operations, 1 for done operations).\"] #[ink(message)]\n    #[ink(selector = 3988478265u32)] fn\n    get_timestamp(& self, id : OperationId) -> Timestamp ;\n    #[doc = \" Returns the minimum delay for an operation to become valid.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" This value can be changed by executing an operation that calls `update_delay`.\"]\n    #[ink(message)] #[ink(selector = 3852146035u32)] fn get_min_delay(& self)\n    -> Timestamp ;\n    #[doc = \" Returns the identifier of an operation containing a single\"]\n    #[doc = \" transaction.\"] #[ink(message)] #[ink(selector = 3432286849u32)]\n    fn\n    hash_operation(& self, transaction : Transaction, predecessor : Option <\n    OperationId >, salt : [u8 ; 32]) -> Hash ;\n    #[doc = \" Returns the identifier of an operation containing a batch of\"]\n    #[doc = \" transactions.\"] #[ink(message)] #[ink(selector = 4030034614u32)]\n    fn\n    hash_operation_batch(& self, transactions : Vec < Transaction >,\n    predecessor : Option < OperationId >, salt : [u8 ; 32],) -> Hash ;\n    #[doc = \" Schedule an operation containing a single transaction.\"]\n    #[doc = \"\"] #[doc = \" Emits a `CallScheduled` event.\"] #[doc = \"\"]\n    #[doc = \" Node: The caller must have the \\'PROPOSER_ROLE\\' role.\"]\n    #[ink(message)] #[ink(selector = 2411105774u32)] fn\n    schedule(& mut self, transaction : Transaction, predecessor : Option <\n    OperationId >, salt : [u8 ; 32], delay : Timestamp,) -> Result < (),\n    TimelockControllerError > ;\n    #[doc = \" Schedule an operation containing a batch of transactions.\"]\n    #[doc = \"\"]\n    #[doc = \" Emits one `CallScheduled` event per transaction in the batch.\"]\n    #[doc = \"\"]\n    #[doc = \" Node: The caller must have the \\'PROPOSER_ROLE\\' role.\"]\n    #[ink(message)] #[ink(selector = 3404191332u32)] fn\n    schedule_batch(& mut self, transactions : Vec < Transaction >, predecessor\n    : Option < OperationId >, salt : [u8 ; 32], delay : Timestamp,) -> Result\n    < (), TimelockControllerError > ; #[doc = \" Cancel an operation.\"]\n    #[doc = \"\"] #[doc = \" On success a `Cancelled` event is emitted.\"]\n    #[doc = \"\"]\n    #[doc = \" Note: the caller must have the \\'PROPOSER_ROLE\\' role.\"]\n    #[ink(message)] #[ink(selector = 3457228928u32)] fn\n    cancel(& mut self, id : OperationId) -> Result < (),\n    TimelockControllerError > ;\n    #[doc = \" Execute an (ready) operation containing a single transaction.\"]\n    #[doc = \"\"] #[doc = \" Emits a `CallExecuted` event.\"] #[doc = \"\"]\n    #[doc = \" Note: The caller must have the \\'EXECUTOR_ROLE\\' role.\"]\n    #[ink(message, payable)] #[ink(selector = 767509891u32)] fn\n    execute(& mut self, transaction : Transaction, predecessor : Option <\n    OperationId >, salt : [u8 ; 32],) -> Result < (), TimelockControllerError\n    > ;\n    #[doc =\n    \" Execute an (ready) operation containing a batch of transactions.\"]\n    #[doc = \"\"]\n    #[doc = \" Emits one `CallExecuted` event per transaction in the batch.\"]\n    #[doc = \"\"]\n    #[doc = \" Note: The caller must have the \\'EXECUTOR_ROLE\\' role.\"]\n    #[ink(message, payable)] #[ink(selector = 3704973290u32)] fn\n    execute_batch(& mut self, transactions : Vec < Transaction >, predecessor\n    : Option < OperationId >, salt : [u8 ; 32],) -> Result < (),\n    TimelockControllerError > ;\n    #[doc = \" Changes the minimum timelock duration for future operations.\"]\n    #[doc = \"\"] #[doc = \" Emits a `MinDelayChange` event.\"] #[doc = \"\"]\n    #[doc = \" Note: The caller must has `TIMELOCK_ADMIN_ROLE` itself.\"]\n    #[doc = \" This can only be achieved by scheduling and later executing\"]\n    #[doc =\n    \" an operation where the timelock is the target and the data is the\"]\n    #[doc = \" ABI-encoded call to this function.\"] #[ink(message)]\n    #[ink(selector = 884960752u32)] fn\n    update_delay(& mut self, new_delay : Timestamp) -> Result < (),\n    TimelockControllerError > ;\n}"